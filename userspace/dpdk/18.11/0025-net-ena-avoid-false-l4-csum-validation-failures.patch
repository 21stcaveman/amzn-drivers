From 23eea99ed02568e45cbeaed9b96bc553527a14ec Mon Sep 17 00:00:00 2001
From: Igor Chauskin <igorch@amazon.com>
Date: Tue, 22 Dec 2020 11:48:36 +0200
Subject: [PATCH] net/ena: avoid false l4 csum validation failures

The driver should ignore l4 csum validation errors
for fragments and also when the offload is disabled
by the application.

Signed-off-by: Igor Chauskin <igorch@amazon.com>
---
 drivers/net/ena/ena_ethdev.c | 29 ++++++++++++++++++++++++-----
 1 file changed, 24 insertions(+), 5 deletions(-)

diff --git a/drivers/net/ena/ena_ethdev.c b/drivers/net/ena/ena_ethdev.c
index a07bd2b49..6cab4a3f0 100644
--- a/drivers/net/ena/ena_ethdev.c
+++ b/drivers/net/ena/ena_ethdev.c
@@ -292,7 +292,8 @@ static inline int ena_cpu_to_node(int cpu)
 }
 
 static inline void ena_rx_mbuf_prepare(struct rte_mbuf *mbuf,
-				       struct ena_com_rx_ctx *ena_rx_ctx)
+				       struct ena_com_rx_ctx *ena_rx_ctx,
+					   uint64_t rx_offloads)
 {
 	uint64_t ol_flags = 0;
 	uint32_t packet_type = 0;
@@ -307,10 +308,26 @@ static inline void ena_rx_mbuf_prepare(struct rte_mbuf *mbuf,
 	else if (ena_rx_ctx->l3_proto == ENA_ETH_IO_L3_PROTO_IPV6)
 		packet_type |= RTE_PTYPE_L3_IPV6;
 
-	if (unlikely(ena_rx_ctx->l4_csum_err))
-		ol_flags |= PKT_RX_L4_CKSUM_BAD;
+	if(!ena_rx_ctx->frag) {
+		/* L4 csum error flag is valid only for non-fragmented packets
+		 * and if the L4 csum was checked.
+		 * ENA's HAL in this version doesn't expose the flag that indicates
+		 * whether it was checked.
+		 * As a partial mitigation we ignore the error flag if the application
+		 * has disabled the offload.
+		 */
+		if (unlikely(ena_rx_ctx->l4_csum_err))
+			if( ((rx_offloads & DEV_RX_OFFLOAD_TCP_CKSUM) && (packet_type & RTE_PTYPE_L4_TCP)) ||
+				((rx_offloads & DEV_RX_OFFLOAD_UDP_CKSUM) && (packet_type & RTE_PTYPE_L4_UDP)) )
+					ol_flags |= PKT_RX_L4_CKSUM_BAD;
+	}
+
+	/* L3 csum error flag should be ignored if the application
+	 * has disabled the offoad
+	 */
 	if (unlikely(ena_rx_ctx->l3_csum_err))
-		ol_flags |= PKT_RX_IP_CKSUM_BAD;
+		if(rx_offloads & DEV_RX_OFFLOAD_IPV4_CKSUM)
+			ol_flags |= PKT_RX_IP_CKSUM_BAD;
 
 	mbuf->ol_flags = ol_flags;
 	mbuf->packet_type = packet_type;
@@ -1884,6 +1901,8 @@ static uint16_t eth_ena_recv_pkts(void *rx_queue, struct rte_mbuf **rx_pkts,
 	struct ena_com_rx_ctx ena_rx_ctx;
 	int rc = 0;
 
+	uint64_t app_offloads = rx_ring->adapter->rte_eth_dev_data->dev_conf.rxmode.offloads;
+
 	/* Check adapter state */
 	if (unlikely(rx_ring->adapter->state != ENA_ADAPTER_STATE_RUNNING)) {
 		RTE_LOG(ALERT, PMD,
@@ -1944,7 +1963,7 @@ static uint16_t eth_ena_recv_pkts(void *rx_queue, struct rte_mbuf **rx_pkts,
 		}
 
 		/* fill mbuf attributes if any */
-		ena_rx_mbuf_prepare(mbuf_head, &ena_rx_ctx);
+		ena_rx_mbuf_prepare(mbuf_head, &ena_rx_ctx, app_offloads);
 		mbuf_head->hash.rss = ena_rx_ctx.hash;
 
 		/* pass to DPDK application head mbuf */
-- 
2.29.2

